## 자바스크립트 기초     

### 2-1 자바스크립트의 특징   
프로그래밍 언어 측면에서 자바스크립트가 지닌 특징.  
- 인터프리터 언어   
- c언어나 자바와 닮은 구문   
- 동적 타입 언어    
- 프로토타입 기반 객체 지향   
- 리터럴 표기의 표현력   
- 함수 타입 프로그래밍    

<hr>

 인터프리터 언어

**동적 타입 언어**     
변수나 함수의 반환값에 타입을 지정하지 않는다. 동적 타입 언어인 자바스크립트도 개발의 용이성을 우선한 결과이다.    

  
**프로토타입 기반 객체 프로토 타입 기반 객체 지향**    
: 객체 지향 언어를 지향하는 많은 언어는 클래스 기반 객체 지향을 지원하는 기능을 제공.   
프로토타입 기반 객체 지향은 자바스크립트가 세계 최초는 아니지만 이름 있는 언어 사이에서는 최초라고 해도 좋다.    


**리터럴 표기의 표현력**   
: 자스의 개발 생산성을 높이는 것 중 하나가 리터럴 표기의 표현력이다    


**함수형 프로그래밍**  

- 2-2-1. **print 함수**  
웹 브라우저에서 코드를 실행 하려면 alert 또는 document.write 로 바꿔서 사용. 파이어버그나 node.js 를 사용하면 console.log 함수로 바꿔서 사용.   

<hr>     

### 2-3. 변수의 기초     

2-3-1.  **변수 사용법**   
변수의 역할은 값이나 객체에 이름을 붙이는 것.    
변수 선언 시 키워드 var 사용해 선언.   
`js > var foo;  //변수 foo 를 선언. ` 


변수에 값을 대입하려면 대입 연산자(=) 를 사용. 대입 연산자의 좌변에 변수, 우변에 대입 값을 기슬.    
`js > foo = “abc”;   // 변수 foo에 문자열 값 “abc”를 대입  `    

     
선언과 대입랄 동시에 할 수 있다. 선언과 대입을 동시에 하는 것은 좋운 프로그래밍 스타일이다.     
`js > var foo = “abc”;  // 문자열 값 ”abc” 을 갖는 변수 foo 를 선언 `


변수에는 타입이 없으므로 변수에 문자열 값을 대입하거나 숫자 값을 대입.    


식 안에 쓴 변수의 역할은 좌변값과 우변값에 차이가 있다. 좌변값이란 대입식에서 = 의 왼쪽에 쓰는 변수명이다.   
우변값에 쓴 변수가 값을 꺼내는 역할을 하는 데 비해 좌변값에 쓴 변수는 대입할 곳을 나타내는 역할을 한다. 
좌변값과 우변값의 차에는 대입할 곳인가 아닌가를 구별하는 것이라고 생각하면 된다. 

선언만 하고 아무 대입하지 않은 변수에는 undefined 값이 할당 된다.     
선언하지 않은 변수의 값을 꺼내면(우변값에서 사용) referenceError 예외가 발생한다. 좌변값에서의 이용. 즉 대입할 곳으로 이용하면 에러가 발생하지 않는다.     


- 2-3-2. **var 생략**    
변수를 var 로 선언한다고 설명했지만 var 로 선언하지 않고 변수에 값을 대입할 수 있다 이런 변수를 암묵적으로 선언한 변수 라고 한다.   
암묵적 선언을 이용한 변수는 전역 변수가 된다. 암묵젓 선언은 함수 안이라도 전역 변수가 된다.   
함수 외부에서 var 를 선언한 변수는 전역변수, 이것은 의도한 전역 변수. 의도한 전역 변수와 구별하기 위해 var 를 선언하지 않은 변수를 암묵적 전역 변수.   


- 2-3-3. **상수**     
상수랄 선언하랴면 키워드 var 대신 const 시용. 상수로 사용할 수 있는 문자는 변수로 사용할 수 있는 문자와 같지만 상수는 모두 대문자러 적는 관례가 있다.   
`js > const F00 = 7; // 상수 선언`


상수에 새로운 값을 다시 대입해도 상수값은 변하지 않는다. 
```
Js› const F00 = 7; 
js > F00 = 8;     //상수에 재차 대입
js› print (FOO);   // 값은 바뀌지 않는다. 
7
```
상수 선언시 대입 하지 않은 상수 값은 undefined 이다. 이러한 동작 방식은 변수와 같다.

<hr>

### 2-4. 함수의 기초
2-4-1. **함수란?** 
함수는 어떤 일련의 과정(코드모음)을 모아서 외부에서 호출할 수 있게 하는 구조이다. 함수에 인자를 건내고, 함수는 값을 반환한다.    
함수 본체를 선언하는 것만으로는 실행 되지 않는다. 함수가 호출되면 처음으로 함수 본체의 코드를 실행한다.   

- 함수를 포함한 코드의 실행 순서
```
print('1');
function f() {
  print('2')  // 함수 선언
}
print('3');
f();        // 함수 호출

//실행 결과는 값이 없음.
```

- 2-4-2. **함수 선언과 호출**
함수를 정의 할 때는 함수 선언문 사용. funvtion 키워드로 시작해 함수명, 인자 목록, 함수 본문을 선언.    
```
//함수 선언문의 문법
function 함수명 (인자, 인자, ...) {
  함수 본문
}
```
예제2-2     
```
function sum(a, b) {
  return Number(a) + Number(b);
}
```
위 예제는 함수명을 sum, 인자명은 a,b 이다. 함수 선언부에 작성한 인자를 형식 인자라고 한다. sum 함수는 두 개의 인자를 더해 그 결과를 return 문으로 반환한다.   

sum 함수를 호출하는 쪽의 코드는 다음과 같다. 함수를 호출할 때 전달하는 인자를 실질인자 라고한다.  
아래는 인자 3과 4로 함수 sum을 호출하는 코드이다.  

```
js > sum(3,4);
7
```

함수 선언부의 형식 인자에도 타입을 지정하지 않는다. 어떤 타입의 값이라도 실질 인자로 넘길 수 있다. 예상하지 못한 타입의 값을 넘겼을 때는 함수 본체를 만드는 개발자의 책임.   
자바스크립트에는 함수 오버로드(이름은 같지만 인자가 다른 함수) 같은 구조는 없다.   


- 2-4-3. 함수 리터럴  
함수는 리터럴 식으로도 정의. 구문상 function 으로 시작해 생략 가능한 함수명, 인자 목록, 함수 본체를 정의한다.  
```
//함수 리터럴 식의 문법
function (인자, 인자, ...) {
   함수 본문
}
function 함수명 (인자, 인자, ...) {
  함수 본문 
}
```
함수 리터럴은 식이기 때문에 식 안에 작성할 수 있고 식이므로 값을 반환한다. 함수 리터럴 식이 반환하는 값은 함수 객체의 참조이다. (5장 변수와 객체)  
단순히 함수를 반환한다고 생각.   

- 함수 리터럴 식의 예  
```
var sum2 = function(a,b) {
             return Number(a) + Number(b); 
}
```
var 로 시작하므로 sum2는 변수명이다. funtion으로 시작하는 함수 리터럴 식은 함수를 반환한다. 즉, 변수 sum2 로 함수 객체의 참조를 대입하는 코드이다.  
변수 sum2가 참조하는 함수는 다음과 같이 호출한다.   

```
//변수 sum2가 참조하는 함수는 다음과 같이 호출
js > sum2(3,4);
7
```

```
//예제 2-2의 함수명을 대입식의 우변에 기술
var sum3 = sum;
//함수 sum3 호츌
sum3(3,4);
7
```

- **2-4-4 함수는 객체**   

객체는 이름이 없다. 함수도 객체다.   
이름없는 함수를 이름으로 부르기 위해 함수명이 존재.    
변수명 = 함수명   
함수는 실행 가능한 코드를 가지며, 호출 가능하다는 의미의 객체.   

<hr>

### 2-5 객체의 기초

#### 2-5-1 객체란?  
객체는 이름과 값으로 구성된 세트의 집합.   

- 객체 특징  
  - 프로퍼치 값에 함수를 지정할 수 있다.  
  - 프로토타입 체인 구조   
 

#### 2-5-2 객체 리터럴 식과 객체의 이용  
객체는 객체 리터럴 식으로 생성할 수 있다. 객체 리터럴 식은 중괄호 {} 로 감싸서 프로퍼티 이름과 프로퍼티 값 집합을 지정한다.  
```
//객체 리터럴 식의 문법
{ 프로퍼티 이름: 프로퍼티 값, 프로퍼티 이름: 프로퍼티 값, ...}  
```

프로퍼티 이름은 식별자, 문자열 값, 숫자 값 중 하나이다.  
프로퍼티 값으로는 임의의 값이나 객체를 작성할 수 있다.  

- 객체 리터럴의 예 
```
{x:2, y:1 }
//프로퍼티명이 식별자
{ "x"22, "y"13
//프로퍼티명이 문자열 값
{ 'x':2, 'y':1 }
//프로퍼티명이 문자열 값
{ 1:2, 2:1 }
//프로퍼티명이 숫자 값
{ x:2, y: 1, enable:true, color: (r:255, g:255, b:255} } 
// 여러 가지 타입의 프로퍼티 값
```

대입식의 우변에 객체 리터럴을 쓰면 객체 참조를 변수에 대입할 수 있다.  
```
//오브젝트 리터럴 식과 대입식
jsy var obj = { x:3, y:4 };    //생성한 개체의 참조를 변수 obj에 대입
js> typeof obj;                //typeof 연산자로 타입을 평가하면 object
object
```

변수 obj 가 참조하는 객체를 객체 obj 라고 한다.   

#### 2-5-3 프로퍼티 접근  
객체 참조에 대해 점 연산(.)을 이용하면 프로퍼티에 접근할 수 있다. 점 연산자의 뒤에 프로퍼티명을 쓰면 프로퍼티 값을 읽을 수 있다.   
`print(obj.x); 3  //obj 객체의 프로퍼티 x의 값을 표시 `  

프로퍼티 접근식을 대입식의 좌변에 쓰면 프로퍼티에 값을 대입할 수 있다.   
``` 
obj.x = 33;  //프로퍼티 값에 덮어 쓰기
print(obj.x);
33
```

#### 2-5-4 프로퍼티 접근(대괄호)  
대괄호 연산자로도 프로퍼티에 접근 가능    
[] 안에는 프로퍼티 명을 나타내는 문자열 값 지정.   

`print(obj['x']) //obj.x와 같음`   

문자열 값을 가진 변수도 쓸 수 있다.   
```
var name = 'x';
print(obj[name]);  //obj.x 와 같음
```

대괄호 연산식은 대입식의 왼쪽에도 사용할 수 있다.  
`obj['z'] = 5; //프로퍼티 z에 숫자 값 5를 대입(프로퍼티 z가 존재하지 않으면 새로 추가)`  

#### 메서드 
객체의 프로퍼티에는 임의 타입의 값이나 객체, 또는 함수를 대입할 수 있다.   
함수 리터럴 식을 평가한 값은 함수 객체의 참조이므로 다음과 같이 작성한다.  

```
obj.fn = function(a,b) {return Number(a) + Number(b); }; 

//obj 객체의 프로퍼티 fn 에 함수를 대입. 
```

프로퍼티에 대입한 함수는 다음과 같이 호출할 수 있다.   
```
obj.fn(3, 4) //함수 호출
7
```

객체의 프로퍼티에 함수를 지정하면 메서드처럼 호출할 수 있다.  


#### 2-4-6 new   
객체 성성을 위해 new 식이 있다.   
```
//new 식의 예 
var obj = new objact();
typeof obj;         // typeobj 연산자로 타입을 판단하면 object 
object
```

new 식으로 생성한 객체는 지금까지 설명한 객체 리터럴 식으로 생성한 객체처럼 프로퍼티에 접근할 수 있다.   
new 키워드 뒤에 쓰는 것은 클래스 이름.   
자바스크립트는 클래스가 없고, 언어 사양상 new 뒤에 쓰는 것은 함수명이다. new 뒤에 함수명을 쓸 때 해당 함수를 생성자로서 호출.    


### 클래스와 인스턴스  

실제 생성자 호출을 가정하고 있는 함수 객체를 클래스라고 한다. 또한 생성자 호출에 의한 생성을 강조하고 싶을 때는 생성한 객체를 인스턴스 객체라고 한다.  


#### 배열의 기초   

배열은 순서가 있는 값의 집합을 표현하는 언어 기능이다. 자스는 내장 타입으로 배열 타입을 가지고 있지 않다.  
그 대신 array 클래스가 있고 배열은 array 클래스의 인스턴스로 존재한다.  
```
//배열 리터럴의 예
var arr = [1,100,7];
```

배열 안의 각 값을 요소 라고 한다. 각 요소는 인덱스로 접근할 수 있다. 인덱스는 0부터 시작하는 정수.  
위의 배열에서 두 번째 요소는 대괄호 안에 인덱스 값을 써서 읽는다.  

```
//앞의 코드 이어짐
print(arr[1]);   //인덱스 값이 1인 요소를 읽어 출력
100
arr[1] = 200 ;   //인덱스 값이 1인 요소에 값을 할당
print(arr[1]);
200
```


